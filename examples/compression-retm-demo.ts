/**
 * Compression + RETM Architecture Demo
 * 
 * This example demonstrates how compression works with the RETM architecture:
 * 1. CompressionTransform (Phase 2, priority=10) - Compresses old frames
 * 2. ContextTransform (Phase 2, priority=100) - Renders context with compression
 * 3. AgentEffector (Phase 3) - Runs agent with pre-rendered context
 * 
 * Run with: ts-node examples/compression-retm-demo.ts
 */

import {
  Space,
  VEILStateManager,
  Element,
  BasicAgent,
  AgentEffector,
  CompressionTransform,
  ContextTransform,
  SimpleTestCompressionEngine,
  MockLLMProvider,
  createSpeechFacet,
  createAgentActivation
} from '../src/index';

async function demonstrateCompression() {
  console.log('='.repeat(60));
  console.log('COMPRESSION + RETM ARCHITECTURE DEMO');
  console.log('='.repeat(60));
  console.log();

  // ========================================
  // SETUP: Core Infrastructure
  // ========================================
  
  console.log('üì¶ Setting up infrastructure...');
  const veilState = new VEILStateManager();
  const space = new Space(veilState);
  const llmProvider = new MockLLMProvider();
  
  // ========================================
  // STEP 1: Create Compression Engine
  // ========================================
  
  console.log('üóúÔ∏è  Creating compression engine...');
  const compressionEngine = new SimpleTestCompressionEngine();
  
  console.log('   ‚úì Using SimpleTestCompressionEngine (no LLM calls)');
  console.log();
  
  // ========================================
  // STEP 2: Register Transforms (Priority Ordering)
  // ========================================
  
  console.log('üîÑ Registering transforms...');
  
  // Transform 1: Compression (priority=10, runs first)
  const compressionTransform = new CompressionTransform({
    engine: compressionEngine,
    engineName: 'simple-test',
    triggerThreshold: 300,        // Compress when > 300 tokens
    minFramesBeforeCompression: 5 // Wait for at least 5 frames
  });
  space.addTransform(compressionTransform);
  console.log(`   ‚úì CompressionTransform (priority=${compressionTransform.priority})`);
  
  // Transform 2: Context Rendering (priority=100, runs after compression)
  const contextTransform = new ContextTransform(
    veilState,
    compressionEngine,  // Same engine instance!
    { maxTokens: 1000 }
  );
  space.addTransform(contextTransform);
  console.log(`   ‚úì ContextTransform (priority=${contextTransform.priority})`);
  console.log('   ‚Üí Execution order guaranteed: Compression ‚Üí Context');
  console.log();
  
  // ========================================
  // STEP 3: Create Agent with Effector
  // ========================================
  
  console.log('ü§ñ Creating agent...');
  
  // Create agent element
  const agentElement = new Element('demo-agent', 'agent');
  space.addChild(agentElement);
  
  // Create agent (NO compression parameter!)
  const agent = new BasicAgent(
    {
      name: 'DemoAgent',
      systemPrompt: 'You are a helpful assistant demonstrating compression.',
      contextTokenBudget: 1000
    },
    llmProvider,
    veilState
  );
  
  console.log('   ‚úì Agent created without compression parameter');
  console.log('   ‚Üí Compression handled by transforms, not agent!');
  
  // Create effector to run agent
  const agentEffector = new AgentEffector(agentElement, agent);
  space.addEffector(agentEffector);
  console.log('   ‚úì AgentEffector registered (Phase 3)');
  console.log();
  
  // ========================================
  // STEP 4: Generate Test Messages
  // ========================================
  
  console.log('üí¨ Generating test conversation (10 frames)...');
  console.log();
  
  // Generate 10 frames with user messages to trigger compression
  for (let i = 1; i <= 10; i++) {
    // Add user message
    space.emit({
      topic: 'veil:operation',
      source: { elementId: 'user', elementPath: [] },
      timestamp: Date.now(),
      payload: {
        operation: {
          type: 'addFacet',
          facet: createSpeechFacet({
            id: `user-msg-${i}`,
            agentId: 'user',
            agentName: 'User',
            content: `This is test message #${i}. It helps demonstrate compression by filling up the frame history.`,
            streamId: 'demo',
            streamType: 'test'
          })
        }
      }
    });
    
    console.log(`   Frame ${i}: User message added`);
    
    // Wait a bit for frame processing
    await new Promise(resolve => setTimeout(resolve, 50));
  }
  
  console.log();
  console.log('   ‚úì 10 frames generated');
  console.log(`   ‚Üí Total frames: ${veilState.getState().frameHistory.length}`);
  console.log();
  
  // ========================================
  // STEP 5: Check Compression Status
  // ========================================
  
  console.log('üìä Checking compression status...');
  
  const state = veilState.getState();
  
  // Look for compression facets
  const compressionPlans = Array.from(state.facets.values())
    .filter(f => f.type === 'compression-plan');
  const compressionResults = Array.from(state.facets.values())
    .filter(f => f.type === 'compression-result');
  
  console.log(`   Compression plans found: ${compressionPlans.length}`);
  console.log(`   Compression results found: ${compressionResults.length}`);
  
  if (compressionResults.length > 0) {
    console.log();
    console.log('   üìã Compression Results:');
    compressionResults.forEach((facet, idx) => {
      const result = (facet as any).state;
      console.log(`      ${idx + 1}. Frames ${result.range.from}-${result.range.to}`);
      console.log(`         Tokens: ${result.range.totalTokens}`);
      console.log(`         Summary: ${result.summary?.substring(0, 60)}...`);
    });
  }
  console.log();
  
  // ========================================
  // STEP 6: Activate Agent
  // ========================================
  
  console.log('üéØ Activating agent...');
  
  // Create agent activation
  space.emit({
    topic: 'veil:operation',
    source: { elementId: 'demo', elementPath: [] },
    timestamp: Date.now(),
    payload: {
      operation: {
        type: 'addFacet',
        facet: createAgentActivation('Demonstrate compression in context', {
          id: `activation-${Date.now()}`,
          priority: 'normal',
          streamId: 'demo',
          streamType: 'test'
        })
      }
    }
  });
  
  console.log('   ‚úì Agent activation sent');
  console.log();
  
  // Wait for processing
  await new Promise(resolve => setTimeout(resolve, 200));
  
  // ========================================
  // STEP 7: Check Rendered Context
  // ========================================
  
  console.log('üìÑ Checking rendered context...');
  
  const updatedState = veilState.getState();
  const contextFacets = Array.from(updatedState.facets.values())
    .filter(f => f.type === 'rendered-context');
  
  if (contextFacets.length > 0) {
    console.log(`   ‚úì Rendered context created: ${contextFacets.length} facet(s)`);
    
    const contextFacet = contextFacets[0];
    const contextData = (contextFacet as any).state;
    console.log(`   Token count: ${contextData.tokenCount}`);
    console.log('   ‚Üí Context includes compressed frames!');
  } else {
    console.log('   ‚ÑπÔ∏è  No rendered context yet (will appear in next frame)');
  }
  console.log();
  
  // ========================================
  // STEP 8: Show Architecture Flow
  // ========================================
  
  console.log('üèóÔ∏è  Architecture Flow Summary:');
  console.log();
  console.log('   Phase 0: Event Preprocessing (Modulators)');
  console.log('      ‚îî‚îÄ No modulators in this demo');
  console.log();
  console.log('   Phase 1: Events ‚Üí VEIL (Receptors)');
  console.log('      ‚îî‚îÄ User messages converted to facets');
  console.log();
  console.log('   Phase 2: VEIL ‚Üí VEIL (Transforms)');
  console.log('      ‚îú‚îÄ CompressionTransform (priority=10)');
  console.log('      ‚îÇ  ‚îî‚îÄ Compresses old frames when threshold met');
  console.log('      ‚îÇ  ‚îî‚îÄ Updates engine cache');
  console.log('      ‚îî‚îÄ ContextTransform (priority=100)');
  console.log('         ‚îî‚îÄ Renders context for agent activation');
  console.log('         ‚îî‚îÄ Uses compressed frames from cache');
  console.log();
  console.log('   Phase 3: VEIL Changes ‚Üí Side Effects (Effectors)');
  console.log('      ‚îî‚îÄ AgentEffector');
  console.log('         ‚îî‚îÄ Sees activation + rendered-context facets');
  console.log('         ‚îî‚îÄ Runs agent with pre-rendered context');
  console.log('         ‚îî‚îÄ Emits agent response facets');
  console.log();
  console.log('   Phase 4: Maintenance (Maintainers)');
  console.log('      ‚îî‚îÄ No maintainers in this demo');
  console.log();
  
  // ========================================
  // SUMMARY
  // ========================================
  
  console.log('='.repeat(60));
  console.log('‚úÖ DEMO COMPLETE');
  console.log('='.repeat(60));
  console.log();
  console.log('Key Takeaways:');
  console.log();
  console.log('1. üî¢ Transform Priority: Ensures correct execution order');
  console.log('   ‚Ä¢ CompressionTransform (10) runs before ContextTransform (100)');
  console.log('   ‚Ä¢ Order matters because they share the engine instance');
  console.log();
  console.log('2. üß© Separation of Concerns:');
  console.log('   ‚Ä¢ Agent doesn\'t manage compression');
  console.log('   ‚Ä¢ Transforms handle infrastructure');
  console.log('   ‚Ä¢ Effectors connect everything');
  console.log();
  console.log('3. üìä Observable:');
  console.log('   ‚Ä¢ Compression creates facets (compression-plan, compression-result)');
  console.log('   ‚Ä¢ Context rendering creates facets (rendered-context)');
  console.log('   ‚Ä¢ Everything visible in VEIL state');
  console.log();
  console.log('4. üîÑ Reusable:');
  console.log('   ‚Ä¢ One compression engine serves all agents');
  console.log('   ‚Ä¢ One set of transforms handles all compression');
  console.log('   ‚Ä¢ Multiple agents can share the infrastructure');
  console.log();
  
  // Clean up
  process.exit(0);
}

// Run the demo
demonstrateCompression().catch(error => {
  console.error('Demo error:', error);
  process.exit(1);
});

